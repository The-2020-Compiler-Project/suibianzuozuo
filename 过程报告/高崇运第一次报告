一.摘要
负责文法设计和词法分析。第一阶段把文法设计三套，各套依次扩展内容，分别用作
第一次使用，第二次使用，第二次使用待选。第二阶段设计第一次词法分析器，首先
一次送入一个Token序列，同时填写符号表，送出Token序列时添写总表的name，单
独的函数填写总表的类型，种类和地址。
关键词：文法，词法分析器，填写符号表

二.阶段设计任务及要求
1.设计任务
设计文法，设计能一次送入一个Token序列的词法分析器，修改文法为左递归，
把设计的符号表填好；
2.设计要求
文法要正确生成简易的程序，容易转换为程序表示，也就是非终结符要有明确意义，
从中容易看出程序包含的所有单词，即终结符，每一个产生式包含一个完整的语义，
易于进行语义分析；词法分析器传出的Token序列包含单词本身，单词的类码和单词
在程序中的序号；符号表的设计遵从给出的结构，能按照给出的数据结构、通过给定
的指针正确访问。

三.第一阶段总体设计
1.文法
首先设计只生成算术表达式、赋值语句和主函数、数据类型为整型、字符型和实型的文法，然后
添加复杂初始化语句，选择语句，循环语句和字符串类型，最后添加二维数组，指针，
函数调用和输入输出；
2.词法分析器
首先扫描单词，得出每个单词的内容和类码并且返回，然后在每个单词类码得出后把
除了常数外的单词填入符号表的name，得到符号表的链表结构，最后编写函数遍历
符号表，把符号表的类型指针（指向三个int,char,float地址中的一个）、种类和地址
三个属性。

四.程序设计与实现
1.文法
（1）第一次文法（英文部分是其他组员写的）
·程序定义
<程序>  int main <分程序>.
PROGRAM ->int main SUB_PROGRAM
<分程序>  { <语句表><返回>}
SUB_PROGRAM ->{STAMENT_TABLE BACK}
·语句定义
<变量说明>  <类型><标识符表> ;
VARIABLE -> TYPE ID_TABLE;
<标识符表>  <标识符><下一标识> 
<下一标识> -> ,<标识符表> | ω   //这两行对应于下面的一句
ID_TABLE -> id {,id}
<语句表>  <赋值语句> <语句表> | <变量说明><语句表> | ω
STATEMENT_TABLE -> ASSIGNMENT_STATEMENT STATEMENT_TABLE | VARIABLE STATEMENT_TABLE | ω
<赋值语句>  <标识符> = <算术表达式> ;
ASSIGNMENT_STATEMENT ->id = ARITHMETIC_EXPRESSION;
<返回>return <返回值>; 
BACK -> return BACK_NUM
<返回值> -> <标识符> | <整数>
BACK_NUM -> id | SIGNED_NUM
·算术表达式定义
	<算术表达式>-><算术表达式>ω0 <项> | <项>
	ARITHMETIC_EXPRESSION -> ARITHMETIC_EXPRESSION ω0 TERM|TERM
<项>  <项> ω1  <因子> | <因子>
TERM -> TERM ω1  FACTOR|FACTOR
<因子>  <算术量> | ( <算术表达式> )
FACTOR -> ARITHMETIC_QUANTITY|(ARITHMETIC_EXPRESSION)
<算术量>  <标识符> | <常数> 
ARITHMETIC_QUANTITY -> ID | CONS
·类型定义
<类型>  int | float | char
TYPE -> int | float | char
·单词集定义
<标识符>  <字母> <标识符字符串>
ID -> W | ISTR 
<标识符字符串>  <字母> <标识符字符串> | <数字> <标识符字符串> | ω
ISTR -> W ISTR | NUM ISTR | ω
<常数>  <整数> | <实数>
CONS -> SIGNED_NUM | REAL
<整数>  ω0 <无符号数> | <无符号数>
SIGNED_NUM ->  UNSINGED_NUM | UNSIGNED_NUM
<无符号数>  <数字> <无符号数> | ω
UNSIGNED_NUM ->NUM UNSIGNED_NUM | ω
<实数>  <整数> . <无符号数>
REAL -> SIGNED_NUM . UNSIGNED_NUM
·字符集定义
<字母>  A|B|C|…|Z|a|b|c|…|z
<数字>  0|1|2|3|4|5|6|7|8|9

  其中：ω0 — +或-
        ω1 — *或/

（2）第二次文法
·程序定义
<程序>  <类型> main <分程序>.
<分程序>  {<变量说明> <复合语句><返回>}

·语句定义
<变量说明>  <类型><标识符表>; | <字符类型><标识符表char>;  
<标识符表>  <数组初始化语句>,<标识符表>|<赋值语句>,<标识符表> | <标识符> , <标识符表> | <数组初始化语句> | <赋值语句> | <标识符>
<标识符表char>  <字符数组初始化语句>,<标识符表char>|<赋值语句>,<标识符表char> | <标识符> , <标识符表char> | <数组初始化语句> | <赋值语句> | <标识符>
<数组初始化语句> -><标识符> [ <无符号整数> ] | <标识符> [] = <一维> | <标识符> [] [<无符号整数>]= <二维> | <标识符> [ <无符号整数> ] = <一维> | <标识符> [ <无符号整数> ] [<无符号整数>]= <二维>
<字符数组初始化语句> -><标识符> [ <无符号整数> ] | <标识符> [] = <字符串> | <标识符> [] [<无符号整数>]= <字符串组> | <标识符> [ <无符号整数> ] = <字符串> | <标识符> [ <无符号整数> ] [<无符号整数>]= <二维字符串>
<复合语句> -> <语句表> | <选择语句> | <循环语句> 
<选择语句> -> <选择条件>; | <选择条件> <复合语句> | <选择条件> {<复合语句>}
<选择条件> -> if <条件判断> |else if <条件判断> | else
<条件判断> -> (<逻辑表达式>) | (;;<逻辑表达式>) | (<赋值语句>;;<逻辑表达式>) | (<;<算术表达式>;<逻辑表达式>) | (<赋值语句>;<算术表达式>;<逻辑表达式>)
<循环语句> -> <循环条件>; | <循环条件> <复合语句> | <循环条件> {<复合语句>}
<循环条件> -> while <条件判断> | for <条件判断> | do {<复合语句>}while<条件判断>
<语句表>  <赋值语句> ;<语句表> | <变量说明><语句表> | <赋值语句>;
<赋值语句>  <标识符> = <算术表达式> 
<返回>return <标识符>; | return <整数> ;
·算术表达式定义
<算术表达式>  <算术表达式> ω0 <项>  | ω2 <算术表达式> | <算术表达式>ω2 
| <项> 
<项>  <项> ω1  <因子> | <因子>
<因子>  <算术量> | ( <算术表达式> )
<算术量>  <标识符> | <常数>  |’<字母>’
·逻辑表达式定义
	<逻辑表达式> -> <逻辑表达式>ω3 <逻辑表达式> | ω3 <逻辑表达式> | <算术表达式> | <算术表达式>ω4 <算术表达式>
·类型定义
<类型>  int | float 
<字符类型> -> char 
·单词集定义
<标识符>  <字母> | <字母> <标识符字符串>
<标识符字符串> <数字> |  <字母> | <字母> <标识符字符串> | <数字> <标识符字符串> 
<常数>  <整数> | <实数>
<整数>  ω0 <无符号数> 
<无符号数>  <数字> |  <数字> <无符号数>
<实数>  <整数> . <无符号数>
<一维> -> { } | {<数组>}
<数组> -> <数字>,<数组> | <数字>
<二维> -> {} | {<一维组>}
<一维组> -> <一维>,<一维组> | <一维>
<字符串> -> { } | {<字母组>} 
<字母组> -> ‘<字母>’,<字母组> | ‘<字母>’
<二维字符串> -> { } | {<字符串组>}
<字符串组> -> <字符串>,<字符串组> | <字符串>
·字符集定义
<字母>  A|B|C|…|Z|a|b|c|…|z
<数字>  0|1|2|3|4|5|6|7|8|9

其中：ω0 — +或-
        ω1 — *或/
ω2 — ++或—
ω3 — &&或||或!
ω4 — !=或==或>=或<=

（3）第二次待选文法
·程序定义
<程序>  <函数声明><程序> | <函数定义><程序> | int main <分程序>  
<分程序>  { <复合语句><返回>} | {<复合语句><返回>}<函数定义列>
<函数声明> -><类型><标识符>(<形参表>);|<类型><标识符>();
<函数定义> -><类型><标识符>(<形参表>)<分程序> | <类型><标识符>()<分程序>
<函数定义列>-><函数定义>,<函数定义列> | <函数定义>
·语句定义	
<变量说明>  <数类型><标识符表>; | <字符类型><标识符表char>;  | <结构体类型><结构体初始化语句>;
<标识符表>  <数组初始化语句>,<标识符表>|<指针标识符初始化语句>,<标识符表> | <赋值语句>,<标识符表> | <标识符> , <标识符表> | <数组初始化语句> | <指针标识符初始化> | <赋值语句> | <标识符>
<标识符表char>  <字符数组初始化语句>,<标识符表char> | <指针标识符初始化语句>,<标识符表char> | <赋值语句>,<标识符表char> | <标识符> , <标识符表char> | <字符数组初始化语句> | <指针标识符初始化语句> | <赋值语句> | <标识符>
<数组初始化语句> -><标识符> [ <无符号整数> ] | <标识符> [] = <一维> | <标识符> [] [<无符号整数>]= <二维> | <标识符> [ <无符号整数> ] = <一维> | <标识符> [ <无符号整数> ] [<无符号整数>]= <二维>
<字符数组初始化语句> -><标识符> [ <无符号整数> ] | <标识符> [] = <字符串> | <标识符> [] [<无符号整数>]= <字符串组> | <标识符> [ <无符号整数> ] = <字符串> | <标识符> [ <无符号整数> ] [<无符号整数>]= <二维字符串>
<结构体初始化语句> -> <标识符><结构体> |<结构体><标识符序列> | <标识符><结构体><标识符列> | <结构体><标识符列>={<赋值表>} | <标识符><结构体><标识符列>={<赋值表>}
<指针标识符初始化语句> ->*<标识符> | *<标识符> = <标识符> | *<标识符>= &<标识符> | *<标识符> = (<类型> * malloc)(sizeof(<类型>)*<无符号整数>)
<复合语句> -> <语句表> | <选择语句> | <循环语句> 
<选择语句> -> <选择条件>; | <选择条件> <复合语句> | <选择条件> {<复合语句>}
<选择条件> -> if <条件判断> |else if <条件判断> | else
<条件判断> -> (<逻辑表达式>) | (;;<逻辑表达式>) | (<赋值语句>;;<逻辑表达式>) | (;<算术表达式>;<逻辑表达式>) | (<赋值语句>;<算术表达式>;<逻辑表达式>)
<循环语句> -> <循环条件>; | <循环条件> <复合语句> | <循环条件> {<复合语句>}
<循环条件> -> while <条件判断> | for <条件判断> | do {<复合语句>}while<条件判断>
<语句表>  <变量说明><语句表> | <赋值语句> ;<语句表> | <输入语句><语句表> | <输出语句><语句表> | <函数调用><语句表> | <赋值语句>; | <输出语句> | <函数调用> | <返回><语句表>
<赋值语句>  <标识符> = <算术表达式> 
<输入语句> -> scanf(“<格式列>”,<输入标识符列>); 
<输出语句> -> printf(“<格式列>”,<输出标识符列>); 
<函数调用> -> <标识符>(<实参表>);
<返回>return <标识符>; | return <整数> ;
·算术表达式定义
<算术表达式>  <算术表达式> ω0 <项>  | ω2 <算术表达式> | <算术表达式>ω2 
| <项> 
<项>  <项> ω1  <因子> | <因子>
<因子>  <算术量> | ( <算术表达式> ) 
<算术量>  <逻辑表达式> | <结构体标识符> | <数组标识符> | <指针标识符> | <标识符> | <常数>  |’<字母>’
·逻辑表达式定义
	<逻辑表达式> -> <逻辑表达式>ω3 <逻辑表达式> | ω3 <逻辑表达式> | <算术表达式> | <算术表达式>ω4 <算术表达式>
·类型定义
	<类型> -> int | float | char | struct
<数类型>  int | float 
<字符类型> -> char 
<结构体类型> ->struct
·单词集定义
<标识符>  <字母> | <字母> <标识符字符串>
<标识符字符串> <数字> |  <字母> | <字母> <标识符字符串> | <数字> <标识符字符串> 
<数组标识符> -><标识符>[<无符号整数>] | <标识符>[<无符号整数>][<无符号整数>]
<结构体标识符> -><标识符>.<标识符> | <标识符> -><标识符>
<指针标识符> ->*<标识符> | *(<标识符>+<无符号整数>)
<常数>  <整数> | <实数>
<整数>  ω0 <无符号整数> 
<无符号整数>  <数字> |  <数字> <无符号整数>
<实数>  <整数> . <无符号数>
<一维> -> { } | {<数组>}
<数组> -> <数字>,<数组> | <数字>
<二维> -> {} | {<一维组>}
<一维组> -> <一维>,<一维组> | <一维>
<字符串> -> { } | {<字母组>} | “<字符串字母>”
<字母组> -> ‘<字母>’,<字母组> | ‘<字母>’
<字符串字母> -> <字母><字符串字母> | <字母>
<二维字符串> -> { } | {<字符串组>}
<字符串组> -> <字符串>,<字符串组> | <字符串>
<结构体> -> {<变量说明列>}
<变量说明列> -> <变量说明>,<变量说明列> | <变量说明>
<标识符列> -> <标识符>,<标识符列> | <标识符>
<赋值表> -> <一维>,<赋值表> | <二维>,<赋值表> | <字符串>,<赋值表> | <二维字符串>,<赋值表> | <常数>,<赋值表> | ‘<字母>’, <赋值表> | <标识符>,<赋值表> | <一维> | <二维> | <字符串> | <二维字符串> | <常数> | ‘<字母>’ | <标识符>
<格式列> -> %d | %c | %f | %s
<输入标识符列> -> &<标识符>,<输入标识符列> | &<数组标识符>,<输入标识符列> | &<结构体标识符>,<输入标识符列> | <标识符>,<输入标识符列> | <标识符>+<无符号整数> | &<标识符> | &<数组标识符> | &<结构体标识符> | <标识符> | <标识符>+<无符号整数>
<输出标识符列> -> <标识符>,<输出标识符列> | <数组标识符>,<输出标识符列> | <结构体标识符>,<输出标识符列> | <指针标识符>,<输出标识符列> | <标识符> | <数组标识符> | <结构体标识符> | <指针标识符>
<形参表> -><类型><标识符>,<形参表>|<类型>*<标识符>,<形参表> | <数组标识符>,<形参表> | <类型><标识符>[],<形参表> | <类型><标识符>[][<无符号整数>],<形参表> | <类型><标识符> | <类型>*<标识符> | <类型><标识符>[] | <类型><数组标识符> | <类型><标识符>[][<无符号整数>]
	<实参表> -><标识符>,<实参表> |  &<标识符>,<实参表> | <数组标识符>,<实参表> | <结构体标识符>,<实参表> | <指针标识符>,<实参表> | <标识符> | &<标识符> | <数组标识符> | <结构体标识符> | <指针标识符>
·字符集定义
<字母>  A|B|C|…|Z|a|b|c|…|z
<数字>  0|1|2|3|4|5|6|7|8|9

  其中：ω0 — +或-
        ω1 — *或/
ω2 — ++或—
ω3 — &&或||或!
ω4 — !=或==或>=或<=

2.词法分析器
#include"stable.h"
#include<stdio.h>
#include<stdlib.h>
#include<string.h>


struct wordinfo
{
    char word[30];///程序里单词本身
    char wordtype;///单词类型，i为标识符，p为界符，c为常数，k为关键字
};
///以下在全局变量中
int memory=4;
int pword,m,test;
char pw,a,id[3]={'i','c','k'},kword[6][7]={"int","float","char","main","return"};
struct tnode itnode;//先创建一些固定内容
struct tnode rtnode;
struct tnode ctnode;
void fillstable();
void testable();
void stable()
{
    itnode.tval='i';
    itnode.tpoint=NULL;
    itnode.next=&rtnode;

    rtnode.tval='r';
    rtnode.tpoint=NULL;
    rtnode.next=&ctnode;

    ctnode.tval='c';
    ctnode.tpoint=NULL;
    ctnode.next=NULL;

    thead->next=&itnode;//对已有类型表的固定内容连接
    tnode *ttail = &ctnode;//对已有类型表的固定内容连接
}

int main()
{
    stable();
    pword=0;
    FILE*fp;
    snode *p;
    if(!(fp=fopen("f.txt","r")))
    {
        cout<<"can not open the file"<<endl;
        return 1;
    }
    char a='1',id[3]={'i','c','k'},kword[6][7]={"int","float","char","main","return"};
    int i=0,j=0,k=0;//k为0，界符直接送出
    struct wordinfo *thisword[50];

    for(test=0;a!=EOF;test++)
     {
        thisword[test]=(struct wordinfo*)malloc(sizeof(struct wordinfo));
        if (pword)
        {
            thisword[test]->word[0]=pw;
            thisword[test]->word[1]='\0';
            thisword[test]->wordtype='p';
            p=new snode;
            p->name= thisword[test]->word;
            stail->next=p;
            stail=p;
            pword=0;
        }
        else
        {

            a=fgetc(fp);
            while(a==' '||a=='\n'||a=='\r'||a=='\t')
                a=fgetc(fp);

            while(a!=' '&&a!='\n'&&a!='\r'&&a!='\t'&&a!=EOF)
            {
                if(!k&&(a=='{'||a=='}'||a==';'||a==','||a=='='||a=='+'||a=='-'||a=='*'||a=='/'||a=='('||a==')'||a=='['||a==']'))
                {
                    thisword[test]->word[0]=a;
                    thisword[test]->word[1]='\0';
                    thisword[test]->wordtype='p';
                    p=new snode;
                    p->name= thisword[test]->word;
                    stail->next=p;
                    stail=p;

                    break;
                }
                else if(k&&(a=='{'||a=='}'||a==';'||a==','||a=='='||a=='+'||a=='-'||a=='*'||a=='/'||a=='('||a==')'||a=='['||a==']'))
                {
                    pw=a;
                    pword=1;
                    thisword[test]->word[i]='\0';

                    for(m=0;m<5;m++)
                        if(strcmp(thisword[test]->word,kword[m])==0)
                        {
                            j=2;
                            break;
                        }
                    thisword[test]->wordtype=id[j];
                    p=new snode;
                    p->name= thisword[test]->word;
                    stail->next=p;
                    stail=p;
                    break;
                }
                else if(j|| (!i&&(a<='9'&&a>='0')) )
                {
                    if(a<'0'||a>'9')
                    {
                        printf("词法错误2！");
                        pword=0;//还原外层变量
                        stail=shead;//删去已填的符号表
                        return 0;
                    }
                    thisword[test]->word[i]=a;
                    j=1;//表明为常数
                    k=1;//界符放入外层变量
                    i++;
                }
                else if((a>='0'&&a<='9')||(a>='a'&&a<='z')||(a>='A'&&a<='Z'))
                {
                    thisword[test]->word[i]=a;
                    k=1;
                    i++;
                }
                else
                {
                    printf("词法错误1！");
                    pword=0;
                    stail=shead;
                    return 0;
                }
                a=fgetc(fp);
            }
            if(a==' '||a=='\n'||a=='\r'||a=='\t')
            {
                thisword[test]->word[i]=='\0';
                for(m=0;m<5;m++)
                {
                    if(strcmp(thisword[test]->word,kword[m])==0)
                    {
                        j=2;
                        break;
                    }
                }
                thisword[test]->wordtype=id[j];
                p=new snode;
                p->name= thisword[test]->word;
                stail->next=p;
                stail=p;
            }


        }
        i=0;
        j=0;
        k=0;
        printf("%s\n",thisword[test]->word);
        printf("%c\n",thisword[test]->wordtype);
    }
    cout<<"out";
    fclose(fp);
    fillstable();
    testable();
    return 0;
}
void fillstable()
{

     int j=0;
     snode* p=shead;
     snode* q=shead,*q1=shead;
     while(p->next!=NULL)
     {
         //snode* p1=p;//这便于从当前指针获取某些信息后，修改前一指针的信息
         p=p->next;
         cout<<"in";
         if(p->name=="{"||p->name=="}"||p->name==";"||p->name==","||p->name=="="
         ||p->name=="+"||p->name=="-"||p->name=="*"||p->name=="/"||p->name=="("||p->name==")"||p->name=="["||p->name=="]")
         {
             p->cat="p";
             cout<<"p ";
             p->typel=NULL;
             p->addr=-1;
         }
         else if(p->name.at(0)<'0'||p->name.at(0)>'9')
         {
            for(m=0;m<3;m++)
            {
                if(p->name==kword[m])
                {
                    j=1;
                    break;
                }
            }
            if(j)
            {
                p->cat="k";
                cout<<"k ";
                p->typel=NULL;
                p->addr=-1;
                q1=q;
                q=p;
            }
            for(m=3;m<5;m++)
            {
                if(p->name==kword[m])
                {
                    j=2;
                    break;
                }
            }
            if(j==2)
            {
               p->cat="k";
               cout<<"k ";
               p->typel=NULL;
               p->addr=-1;
               if(p->name=="main")
                    q=q1;
            }
            if(!j)
            {
                if(q==shead)///如果是没有给出类型的标识符
                {
                    p->cat="x";///错误类型
                    cout<<"x ";
                    p->typel=NULL;
                    p->addr=-1;
                }
                else
                {
                    p->cat="v";
                    cout<<"v";
                    if(q->name=="int")
                    {
                        p->typel=&itnode;
                        p->addr=memory;
                        memory+=4;
                    }
                    if(q->name=="char")
                    {
                        p->typel=&ctnode;
                        p->addr=memory;
                        memory+=1;
                    }
                    if(q->name=="float")
                    {
                        p->typel=&rtnode;
                        p->addr=memory;
                        memory+=8;
                    }
                }
            }
         }
         j=0;
     }
    return ;
}
void testable()
{
    snode *p=shead;
    cout<<"in";

    while(p->next!=NULL)
    {
        p=p->next;
        cout<<p->cat;
    }
    return ;
}

